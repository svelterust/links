defmodule Links.AccountsUsernameTest do
  use Links.DataCase

  alias Links.Accounts

  describe "username functionality" do
    setup do
      {:ok, user} = Accounts.register_user(%{email: "test@example.com"})
      %{user: user}
    end

    test "generate_username_from_email/1 creates username from email", %{} do
      assert Accounts.User.generate_username_from_email("john.doe@example.com") == "johndoe"
      assert Accounts.User.generate_username_from_email("user-name@test.com") == "username"
      assert Accounts.User.generate_username_from_email("test_user@example.org") == "test_user"
    end

    test "generate_username_from_email/1 handles conflicts with numbers", %{user: user} do
      # user already has username "test"
      assert user.username == "test"

      # Creating another user with same base should get "test1"
      {:ok, user2} = Accounts.register_user(%{email: "test@another.com"})
      assert user2.username == "test1"

      
      # Third user should get "test2"
      {:ok, user3} = Accounts.register_user(%{email: "test@third.com"})
      assert user3.username == "test2"
    end

    test "change_user_username/2 returns a valid changeset", %{user: user} do
      changeset = Accounts.change_user_username(user, %{username: "newusername"})
      assert changeset.valid?
      assert changeset.changes.username == "newusername"
    end

    test "change_user_username/2 validates username format", %{user: user} do
      changeset = Accounts.change_user_username(user, %{username: "Invalid-Username!"})
      refute changeset.valid?
      assert "can only contain lowercase letters, numbers, and underscores" in errors_on(changeset).username
    end

    test "change_user_username/2 validates username length", %{user: user} do
      # Too short
      changeset = Accounts.change_user_username(user, %{username: ""})
      refute changeset.valid?
      assert "can't be blank" in errors_on(changeset).username

      # Too long
      long_username = String.duplicate("a", 51)
      changeset = Accounts.change_user_username(user, %{username: long_username})
      refute changeset.valid?
      assert "should be at most 50 character(s)" in errors_on(changeset).username
    end

    test "update_user_username/2 successfully updates username", %{user: user} do
      assert {:ok, updated_user} = Accounts.update_user_username(user, %{username: "newusername"})
      assert updated_user.username == "newusername"
      assert updated_user.id == user.id
    end

    test "update_user_username/2 prevents duplicate usernames", %{user: user} do
      {:ok, user2} = Accounts.register_user(%{email: "user2@example.com"})
      
      assert {:error, changeset} = Accounts.update_user_username(user2, %{username: user.username})
      refute changeset.valid?
      assert "has already been taken" in errors_on(changeset).username
    end

    test "update_user_username/2 fails with invalid username format", %{user: user} do
      assert {:error, changeset} = Accounts.update_user_username(user, %{username: "Invalid Name!"})
      refute changeset.valid?
      assert "can only contain lowercase letters, numbers, and underscores" in errors_on(changeset).username
    end

    test "update_user_username/2 requires username to change", %{user: user} do
      assert {:error, changeset} = Accounts.update_user_username(user, %{username: user.username})
      refute changeset.valid?
      assert "did not change" in errors_on(changeset).username
    end

    test "username is automatically generated during registration" do
      {:ok, user} = Accounts.register_user(%{email: "auto.generated@example.com"})
      assert user.username == "autogenerated"
    end

    test "username generation handles special characters" do
      {:ok, user} = Accounts.register_user(%{email: "user+tag@example.com"})
      assert user.username == "usertag"
      
      {:ok, user2} = Accounts.register_user(%{email: "user.with.dots@example.com"})
      assert user2.username == "userwithdots"
      
      {:ok, user3} = Accounts.register_user(%{email: "user-with-dashes@example.com"})
      assert user3.username == "userwithdashes"
    end

    test "username validation allows valid formats" do
      valid_usernames = ["test", "test123", "test_user", "user_123", "a", "test_user_123"]
      
      Enum.with_index(valid_usernames, fn username, index ->
        {:ok, user} = Accounts.register_user(%{email: "#{username}#{index}@example.com"})
        changeset = Accounts.change_user_username(user, %{username: "#{username}_new"})
        assert changeset.valid?, "Username '#{username}_new' should be valid"
      end)
    end

    test "username validation rejects invalid formats" do
      invalid_usernames = [
        "Test",           # uppercase
        "test-user",      # dash
        "test user",      # space
        "test.user",      # dot
        "test@user",      # @
        "test+user",      # +
        "test!",          # special character
      ]
      
      {:ok, user} = Accounts.register_user(%{email: "validuser@example.com"})
      
      Enum.each(invalid_usernames, fn username ->
        changeset = Accounts.change_user_username(user, %{username: username})
        refute changeset.valid?, "Username '#{username}' should be invalid"
      end)
    end
  end
end